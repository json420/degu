Road to Degu 1.0 (or something like that)
=========================================

Definite
--------

    *   RGI is currently ambiguous when it comes to "no query" (ie, URI does not
        contain a '?') vs "an empty query" (ie, the final character in the URI
        is a '?'); currently both of these scenarios result in the same empty ''
        query string, which means we can't do a lossless round-trip between the
        URI and the (script, path, query) components; when reconstructing the
        URI, the "empty query" case will lose its final '?' on the way out;
        similar to how RGI handles the request and response bodies, "no query"
        should be expressed with {'query': None}, and an "empty query" should be
        {'query': ''}.


    *   Flip the order of items in a single chunk (in a body using chunked
        transfer-encoding) from:

            (data, extension)

        To:

            (extension, data)

        This is the one place where Degu/RGI currently isn't faithful to the
        order in the HTTP wire format.  This is for historic reasons in how Degu
        initially exposed the optional per-chunk extension; however, it's
        inconsistent with the rest of the Degu/RGI API, and should be fixed.


    *   Now that request['uri'] has been added, `degu.rgi.Validator` should
        check that the server correctly parsed the URI into the
        (script, path, query) components, and should likewise check that any
        path shifting done by middleware or applications was done correctly...
        ie, you should always be able to reconstruct the original URI from
        (script, path, query), even if items have been shifted from path to
        script.


    *   `ChunkedBody.read()` should take a size argument and should have the
        same semantics as `Body.read()`; likewise, `ChunkedBody.read()` should
        return bytes instead of a bytearray (in order to match standard Python
        file-like API expectations)


    *   `Body.read()` and `ChunkedBody.read()` need to enforce a sane max read
        size when size=None, as the current implementation allows for unbounded
        resource usage; maybe a max of 16 MiB or thereabouts; but this change
        would introduce a bit of ambiguity about size=None: if you call read()
        with no size argument, are you done reading after that, or did you hit
        an internal sanity limit and still need to make additional calls to
        body.read() to fully read it?

        I don't particularly like the semantics of size=None in the standard
        Python file-like API.  It would be better for consumers to be expected
        to always make successive calls to body.read() till an empty b'' is
        returned; in other words, size=None would no longer mean "read it all",
        but instead would mean "read up to a generously large but still sane
        internal limit, and I'll keep calling body.read() till I get an empty
        b'', after which I know the entire stream has been read."



Likely post Degu 1.0
--------------------

    *   Thus far Degu has focused on "embedding" within applications by running
        the Degu server in a multiprocessing.Process; however, Dmedia will soon
        be running Degu totally in stand-alone script launched via
        subprocess.Popen(); this allows for the Degu server that accepts outside
        connections to be carefully isolated with Apparmor and not share any
        memory space with the main Dmedia process; this is likewise a pattern
        for which Degu should provide a high-level solution, especially for
        security reasons; however, how to capture this in a generic way isn't
        clear at this point.

